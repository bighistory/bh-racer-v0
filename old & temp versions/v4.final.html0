<!DOCTYPE html> 

<html>
<head>
  <title>Javascript Racer - v4 (final)</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="common.css" rel="stylesheet" type="text/css" />
</head> 

<body> 

  <table id="controls">
    <tr><td id="fps" colspan="2" align="right"></td></tr>
    <tr>
      <th><label for="resolution">Resolution :</label></th>
      <td>
        <select id="resolution" style="width:100%">
          <option value='fine'>Fine (1280x960)</option>
          <option selected value='high'>High (1024x768)</option>
          <option value='medium'>Medium (640x480)</option>
          <option value='low'>Low (480x360)</option>
        </select>
      </td>
    </tr>
    <tr>
      <th><label for="lanes">Lanes :</label></th>
      <td>
        <select id="lanes">
          <option>1</option>
          <option>2</option>
          <option selected>3</option>
          <option>4</option>
        </select>
      </td>
    </tr>
		<tr>
      <th><label for="bike">Bike :</label></th>
      <td>
        <input type="checkbox" id="bike">
      </td>
    </tr>
		<tr>
      <th><label for="autoSteer">Autodrive :</label></th>
      <td>
        <input type="checkbox" id="autoSteer">
      </td>
    </tr>
    <tr>
      <th><label for="totalCars">Total Cars (<span id="currentTotalCars"></span>) :</label></th>
      <td><input id="totalCars" type='range' min='0' max='200' title="integer (0-200)"></td>
    <tr>
      <th><label for="roadWidth">Road Width (<span id="currentRoadWidth"></span>) :</label></th>
      <td><input id="roadWidth" type='range' min='500' max='3000' title="integer (500-3000)"></td>
    </tr>
    <tr>
      <th><label for="cameraHeight">CameraHeight (<span id="currentCameraHeight"></span>) :</label></th>
      <td><input id="cameraHeight" type='range' min='500' max='10000' title="integer (500-10000)"></td>
    </tr>
    <tr>
      <th><label for="drawDistance">Draw Distance (<span id="currentDrawDistance"></span>) :</label></th>
      <td><input id="drawDistance" type='range' min='100' max='500' title="integer (100-500)"></td>
    </tr>
    <tr>
      <th><label for="fieldOfView">Field of View (<span id="currentFieldOfView"></span>) :</label></th>
      <td><input id="fieldOfView" type='range' min='80' max='140' title="integer (80-140)"></td>
    </tr>
    <tr>
      <th><label for="fogDensity">Fog Density (<span id="currentFogDensity"></span>) :</label></th>
      <td><input id="fogDensity" type='range' min='0' max='50' title="integer (0-50)"></td>
    </tr>
  </table>

  <div id='instructions'>
    <p>Use the <b>arrow keys</b> to drive the car.</p>
  </div>

  <div id="racer">
    <div id="frame"></div>
    <div id="hud">
      <span id="speed"            class="hud"><span id="speed_value" class="value">0</span> km/h</span>
      <span id="km_remaining" class="hud">Km to go: <span id="km_remaining_value" class="value">0.0</span></span> 
      <span id="current_lap_time" class="hud">Time: <span id="current_lap_time_value" class="value">0.0</span></span> 
      <span id="last_lap_time"    class="hud">Last lap: <span id="last_lap_time_value" class="value">0.0</span></span>
      <span id="fast_lap_time"    class="hud">Segment id: <span id="fast_lap_time_value" class="value">0.0</span></span>
    </div>
		<div id="rotationFrame">
			<canvas id="canvas">
				Sorry, this example cannot be run because your browser does not support the &lt;canvas&gt; element
			</canvas>
		</div>
		<!--div id="buttons">
      <button id="left" class="buttons"> left </button>
      <button id="faster" class="buttons"> faster </button>
      <button id="slower" class="buttons"> slower </button>
      <button id="right" class="buttons"> right </button>
    </div-->
		<div id="left" class="buttons"> left </div>
		<div id="faster" class="buttons"> faster </div>
		<div id="slower" class="buttons"> slower </div>
		<div id="right" class="buttons"> right </div>
		<div id="timeup" class="buttons"> time scale up</div>
		<div id="timedown" class="buttons"> time scale down</div>
    Loading...
  </div>

  <audio id='music'>
    <source src="music/racer.ogg">
    <source src="music/racer.mp3">
  </audio>
  <span id="mute"></span>

  <script src="stats.js"></script>
  <script src="common.js"></script>
  <script>

    var fps            = 60;                      // how many 'update' frames per second
    var step           = 1/fps;                   // how long is each frame (in seconds)
    var width          = 1024;                    // logical canvas width
    var height         = 768;                     // logical canvas height
    var centrifugal    = 0.15;                     // centrifugal force multiplier when going around curves
    var offRoadDecel   = 0.99;                    // speed multiplier when off road (e.g. you lose 2% speed each update frame)
    var skySpeed       = 0.0005;                   // background sky layer scroll speed when going around curve (or up hill)
    var hillSpeed      = 0.0009;                   // background hill layer scroll speed when going around curve (or up hill)
    var treeSpeed      = 0.0011;                   // background tree layer scroll speed when going around curve (or up hill)
    var skyOffset      = 0;                       // current sky scroll offset
    var hillOffset     = 0;                       // current hill scroll offset
    var treeOffset     = 0;                       // current tree scroll offset
    var segments       = [];                      // array of road segments
    var cars           = [];                      // array of cars on the road
    var stats          = Game.stats('fps');       // mr.doobs FPS counter
    var canvas         = Dom.get('canvas');       // our canvas...
    var ctx            = canvas.getContext('2d'); // ...and its drawing context
		//efh offscreen render -- didn't help with moire during rotation and made FPS worse so revert
		// repurpose offscreen canvas to clip timeMarker text
//		var canvas2 = document.createElement('canvas'); // offscreen canvas for prerendering
//			canvas2.setAttribute('width', width);
//      canvas2.setAttribute('height', height);
//			var ctx2 = canvas2.getContext('2d');
		
		//temp canvas used to counterRotate player sprite if bike + autoSteer
		//var canvas3 = document.createElement('canvas'); // offscreen canvas for prerendering
		//	canvas3.setAttribute('width', SPRITES.PLAYER_STRAIGHT.w);
    //  canvas3.setAttribute('height', SPRITES.PLAYER_STRAIGHT.h);
		//var ctx3 = canvas3.getContext('2d');
		//var rotationFrame = document.getElementById("rotationFrame");


    var background     = null;                    // our background image (loaded below)
    var sprites        = null;                    // our spritesheet (loaded below)
    var resolution     = null;                    // scaling factor to provide resolution independence (computed)
		var autoSteer      = false;
		var bike           = true;
		var timeScale = 0; 
    var roadWidth      = 2000;                    // actually half the roads width, easier math if the road spans from -roadWidth to +roadWidth
    var segmentLength  = 200;                     // length of a single segment
    var rumbleLength   = 6;                       // number of segments per red/white rumble strip
    var trackLength    = null;                    // z length of entire track (computed)
    var lanes          = 1;                       // number of lanes
    var fieldOfView    = 100;                     // angle (degrees) for field of view
    var cameraHeight   = 1000;                    // z height of camera
    var cameraDepth    = null;                    // z distance camera is from screen (computed)
    var drawDistance   = 300;                     // number of segments to draw
    var playerX        = 0;                       // player x offset from center of road (-1 to 1 to stay independent of roadWidth)
    var playerZ        = null;                    // player relative z distance from camera (computed)
    var fogDensity     = 0;                       // exponential fog density
    var position       = 0;                       // current camera Z position (add playerZ to get player's absolute Z position)
    var speed          = 0;                       // current speed
    var maxSpeed       = segmentLength/step;      // top speed (ensure we can't move more than 1 segment in a single frame to make collision detection easier)
    var accel          =  maxSpeed/5;             // acceleration rate - tuned until it 'felt' right
    var breaking       = -maxSpeed;               // deceleration rate when braking
    var decel          = -maxSpeed/5;             // 'natural' deceleration rate when neither accelerating, nor braking
    var offRoadDecel   = -maxSpeed/2;             // off road deceleration is somewhere in between
    var offRoadLimit   =  maxSpeed/4;             // limit when off road deceleration no longer applies (e.g. you can always go at least this speed even when off road)
    var totalCars      = 200;                     // total number of cars on the road
    var currentLapTime = 0;                       // current lap time
    var lastLapTime    = null;                    // last lap time
    var currentRotation =0; //horizon tilt

    var keyLeft        = false;
    var keyRight       = false;
    var keyFaster      = false;
    var keySlower      = false;

    var hud = {
      speed:            { value: null, dom: Dom.get('speed_value')            },
      current_lap_time: { value: null, dom: Dom.get('current_lap_time_value') },
      km_remaining:     { value: null, dom: Dom.get('km_remaining_value')     },
      last_lap_time:    { value: null, dom: Dom.get('last_lap_time_value')    },
      fast_lap_time:    { value: null, dom: Dom.get('fast_lap_time_value')    }
    }

    //-------------------------------------------------------------------------
		function createCircle(col,size,rmax,alpha) {
			col = col || true; //random coloured circles
			size = size || 2; //default starting size
			alpha = alpha || 0; //default starting alpha
			rmax = rmax || 25; //default maximum radius

			//parms to create a bigger/whiter explosion (for timescale warps for eg)
			/*col = false;
			size = 10;
			alpha = .98;
			rmax = 300;
			*/
			//Place the circles just below the center
			this.x = canvas.width/2;
			this.y = canvas.height*5/9;
			
			//Random velocities between -20 and +20 (negative value so that they move in both directions)
			this.vx = -20 + Math.random()*40;
			this.vy = -20 + Math.random()*40;
			
			//Random colors
			if (col) {
				this.r = Math.round(Math.random())*255;
				this.g = Math.round(Math.random())*255;
				this.b = Math.round(Math.random())*255;
			} else {
				this.r = 255;
				this.g = 255;
				this.b = 255;
			}

			//Random starting radius and increase speed
			
			this.radius = size + Math.random(); 
			this.vr = .05 + Math.random();
			this.rmax = rmax;
			
			//Random starting alpha and decrease speed
			this.a = Math.max(alpha + Math.random(),1);
			this.va = .01 + Math.random()/20;
		}
		var circles = [];

    //=========================================================================
    // UPDATE THE GAME WORLD
    //=========================================================================

    function update(dt) {

      var n, car, carW, sprite, spriteW;
      var playerSegment = findSegment(position+playerZ);
      var playerW       = SPRITES.PLAYER_STRAIGHT.w * SPRITES.SCALE;
      var speedPercent  = speed/maxSpeed;
      var dx            = dt * 2 * speedPercent; // at top speed, should be able to cross from left to right (-1 to 1) in 1 second
      var startPosition = position;

      updateCars(dt, playerSegment, playerW);

      position = Util.increase(position, dt * speed, trackLength);

			//if (!autoSteer) {
				if (keyLeft)
					playerX = playerX - dx;
				else if (keyRight)
					playerX = playerX + dx;
			//}
		
      playerX = playerX - (dx * speedPercent * playerSegment.curve * centrifugal);
			if (autoSteer) {
				playerX = Util.limit(playerX, -.8, .8);     //keep on path
			}

	 	  if (keyFaster || autoSteer)
        speed = Util.accelerate(speed, accel, dt);
      else if (keySlower)
        speed = Util.accelerate(speed, breaking, dt);
      //else
      //  speed = Util.accelerate(speed, decel, dt);


      if ((playerX < -1) || (playerX > 1)) {

        if (speed > offRoadLimit)
          speed = Util.accelerate(speed, offRoadDecel, dt);

				// need to update collision test to account for new height attribute of sprite
        for(n = 0 ; n < playerSegment.sprites.length ; n++) {
          sprite  = playerSegment.sprites[n];
          spriteW = sprite.source.w * SPRITES.SCALE;
          if (Util.overlap(playerX, playerW, sprite.offset + spriteW/2 * (sprite.offset > 0 ? 1 : -1), spriteW)) {
            speed = maxSpeed/5;
            position = Util.increase(playerSegment.p1.world.z, -playerZ, trackLength); // stop in front of sprite (at front of segment)
            break;
          }
        }
      }

			// see if we are hitting any other players
      for(n = 0 ; n < playerSegment.cars.length ; n++) {
        car  = playerSegment.cars[n];
        carW = car.sprite.w * SPRITES.SCALE;
        if (speed > car.speed) {
          if (Util.overlap(playerX, playerW, car.offset, carW, 0.8)) {
            speed    = car.speed * (car.speed/speed);
            position = Util.increase(car.z, -playerZ, trackLength);
						
						// if we're leaning around a corner when we hit, reset the horizon tilt
						if (currentRotation != 0) {
							ctx.translate(canvas.width/2,canvas.height/2);
							ctx.rotate(currentRotation*(Math.PI/90));
							ctx.translate(-canvas.width/2,-canvas.height/2);
							currentRotation = 0;
						}
						// try out an explosion of sorts
						//circles = baseCircles.slice(0);
						if (circles.length<200) {
							for (var i = 0; i < 100; i++) {
								circles.push(new createCircle());
							}
						}

            break;
          }
        }
      }

      //playerX = Util.limit(playerX, -3, 3);     // dont ever let it go too far out of bounds
			playerX = Util.limit(playerX, -.9, .9);     // dont ever let it go too far out of bounds
      speed   = Util.limit(speed, 0, maxSpeed); // or exceed maxSpeed

      skyOffset  = Util.increase(skyOffset,  skySpeed  * playerSegment.curve * (position-startPosition)/segmentLength, 1);
      hillOffset = Util.increase(hillOffset, hillSpeed * playerSegment.curve * (position-startPosition)/segmentLength, 1);
      treeOffset = Util.increase(treeOffset, treeSpeed * playerSegment.curve * (position-startPosition)/segmentLength, 1);

      if (position > playerZ) {
        if (currentLapTime && (startPosition < playerZ)) {
          lastLapTime    = currentLapTime;
          currentLapTime = 0;
          /*
					if (lastLapTime <= Util.toFloat(Dom.storage.fast_lap_time)) {
            Dom.storage.fast_lap_time = lastLapTime;
            updateHud('fast_lap_time', formatTime(lastLapTime));
            Dom.addClassName('fast_lap_time', 'fastest');
            Dom.addClassName('last_lap_time', 'fastest');
          }
          else {
            Dom.removeClassName('fast_lap_time', 'fastest');
            Dom.removeClassName('last_lap_time', 'fastest');
          }
					*/
          updateHud('last_lap_time', formatTime(lastLapTime));
          Dom.show('last_lap_time');
        }
        else {
          currentLapTime += dt;
        }
      }

      updateHud('speed',            5 * Math.round(speed/500));
      updateHud('current_lap_time', formatTime(currentLapTime));
	    updateHud('km_remaining', Math.floor((trackLength-position)/20000));
		
    }

    //-------------------------------------------------------------------------

    function updateCars(dt, playerSegment, playerW) {
      var n, car, oldSegment, newSegment;
      for(n = 0 ; n < cars.length ; n++) {
        car         = cars[n];
        oldSegment  = findSegment(car.z);
        car.offset  = car.offset + updateCarOffset(car, oldSegment, playerSegment, playerW);
        car.z       = Util.increase(car.z, dt * car.speed, trackLength);
        car.percent = Util.percentRemaining(car.z, segmentLength); // useful for interpolation during rendering phase
        newSegment  = findSegment(car.z);
        if (oldSegment != newSegment) {
          index = oldSegment.cars.indexOf(car);
          oldSegment.cars.splice(index, 1);
          newSegment.cars.push(car);
        }
      }
    }

    function updateCarOffset(car, carSegment, playerSegment, playerW) {

      var i, j, dir, segment, otherCar, otherCarW, lookahead = 20, carW = car.sprite.w * SPRITES.SCALE;

      // optimization, dont bother steering around other cars when 'out of sight' of the player
      if ((carSegment.index - playerSegment.index) > drawDistance)
        return 0;

      for(i = 1 ; i < lookahead ; i++) {
        segment = segments[(carSegment.index+i)%segments.length];

        if ((segment === playerSegment) && (car.speed > speed) && (Util.overlap(playerX, playerW, car.offset, carW, 1.2))) {
          if (playerX > 0.5)
            dir = -1;
          else if (playerX < -0.5)
            dir = 1;
          else
            dir = (car.offset > playerX) ? 1 : -1;
          return dir * 1/i * (car.speed-speed)/maxSpeed; // the closer the cars (smaller i) and the greated the speed ratio, the larger the offset
        }

        for(j = 0 ; j < segment.cars.length ; j++) {
          otherCar  = segment.cars[j];
          otherCarW = otherCar.sprite.w * SPRITES.SCALE;
          if ((car.speed > otherCar.speed) && Util.overlap(car.offset, carW, otherCar.offset, otherCarW, 1.2)) {
            if (otherCar.offset > 0.5)
              dir = -1;
            else if (otherCar.offset < -0.5)
              dir = 1;
            else
              dir = (car.offset > otherCar.offset) ? 1 : -1;
            return dir * 1/i * (car.speed-otherCar.speed)/maxSpeed;
          }
        }
      }

      // if no cars ahead, but I have somehow ended up off road, then steer back on
      if (car.offset < -0.9)
        return 0.1;
      else if (car.offset > 0.9)
        return -0.1;
      else
        return 0;
    }

    //-------------------------------------------------------------------------

    function updateHud(key, value) { // accessing DOM can be slow, so only do it if value has changed
      if (hud[key].value !== value) {
        hud[key].value = value;
        Dom.set(hud[key].dom, value);
      }
    }

    function formatTime(dt) {
      var minutes = Math.floor(dt/60);
      var seconds = Math.floor(dt - (minutes * 60));
      var tenths  = Math.floor(10 * (dt - Math.floor(dt)));
      if (minutes > 0)
        return minutes + "." + (seconds < 10 ? "0" : "") + seconds + "." + tenths;
      else
        return seconds + "." + tenths;
    }

    //=========================================================================
    // RENDER THE GAME WORLD
    //=========================================================================
		// order of objects to render
		// 1. backgrounds (ski, mountains, trees)
		// 2. ground polygon (requires pass thru segments to find horizon line)
		// 3. road segments (back to front, for
		// 4. stationary sprites
		// 5. time markers (treat similar to stationary sprites, clipped by road)
		// 6. moving sprites
		// 7. player sprite

    function render() {

      var baseSegment   = findSegment(position);
      var basePercent   = Util.percentRemaining(position, segmentLength);
      var playerSegment = findSegment(position+playerZ);
      var playerPercent = Util.percentRemaining(position+playerZ, segmentLength);
      var playerY       = Util.interpolate(playerSegment.p1.world.y, playerSegment.p2.world.y, playerPercent);
      var maxy          = height;

      var x  = 0;
      var dx = - (baseSegment.curve * basePercent);
      
	
	//efh moire test - rotate canvas first
	//ctx.save();
	ctx.clearRect(0, 0, width, height);
updateHud('fast_lap_time', baseSegment.index + "/" + segments.length); // test
//updateHud('fast_lap_time',currentRotation); // test
			if (bike) {
				rotation=0;
				//updateHud('km_remaining', baseSegment.curve); // test
				//updateHud('fast_lap_time', currentRotation); // test
				if (baseSegment.curve==0) {
					rotation=-currentRotation;
					currentRotation=0;
				} else {
					//newrot = -Math.round(baseSegment.curve*speed/maxSpeed*24*10)/10;
					newrot = baseSegment.curve*speed/maxSpeed;
					rotation=newrot - currentRotation ;
					currentRotation = newrot ;
				}
				if (rotation!=0) {
					//ctx.save(); // doesn't help with moire problem
					//console.log(rotation);
					ctx.translate(canvas.width/2,canvas.height/2);
					ctx.rotate(-rotation*(Math.PI/90));
					ctx.translate(-canvas.width/2,-canvas.height/2);
					//ctx.restore();
					
					//efh test dom css rotation instead of canvas rotation
//					rotationFrame.style.webkitTransform = "rotate(" + rotation + "deg)";
//					rotationFrame.style.MozTransform = "rotate(" + rotation + "deg)";
//					rotationFrame.style.transform = "rotate(" + rotation + "deg)";
					
					//efh offscreen render
					//ctx2.translate(canvas.width/2,canvas.height/2);
					//ctx2.rotate(-rotation*(Math.PI/90));
					//ctx2.translate(-canvas.width/2,-canvas.height/2);
				}
			}


			//efh offscreen render
      //ctx.clearRect(0, 0, width, height);
			//ctx2.clearRect(0, 0, width, height);

      Render.background(ctx, background, width, height, BACKGROUND.SKY,   skyOffset,  resolution * skySpeed  * playerY);
      Render.background(ctx, background, width, height, BACKGROUND.HILLS, hillOffset, resolution * hillSpeed * playerY);
      Render.background(ctx, background, width, height, BACKGROUND.TREES, treeOffset, resolution * treeSpeed * playerY);
      //Render.background(ctx2, background, width, height, BACKGROUND.SKY,   skyOffset,  resolution * skySpeed  * playerY);
      //Render.background(ctx2, background, width, height, BACKGROUND.HILLS, hillOffset, resolution * hillSpeed * playerY);
      //Render.background(ctx2, background, width, height, BACKGROUND.TREES, treeOffset, resolution * treeSpeed * playerY);

      var n, i, segment, car, sprite, spriteScale, spriteX, spriteY;

			//efh horizon test - store array of segments to render later
			//var segarray = [];
      for(n = 0 ; n < drawDistance ; n++) {

        segment        = segments[(baseSegment.index + n) % segments.length];
        segment.looped = segment.index < baseSegment.index;
        segment.fog    = Util.exponentialFog(n/drawDistance, fogDensity);
        segment.clip   = maxy;

        Util.project(segment.p1, (playerX * roadWidth) - x,      playerY + cameraHeight, position - (segment.looped ? trackLength : 0), cameraDepth, width, height, roadWidth);
        Util.project(segment.p2, (playerX * roadWidth) - x - dx, playerY + cameraHeight, position - (segment.looped ? trackLength : 0), cameraDepth, width, height, roadWidth);

        x  = x + dx;
        dx = dx + segment.curve;

//        if ((segment.p1.camera.z <= cameraDepth)         || // behind us
//            ((segment.p2.screen.y >= segment.p1.screen.y) && (! segment.timeMarker)) || // back face cull
//            (segment.p2.screen.y >= segment.p1.screen.y) || // back face cull
//            (segment.p2.screen.y >= maxy))                  // clip by (already rendered) hill
//          continue;
					
				//efh horizon test - don't render yet, save until we have horizon line, draw grass, then render segments
				//segarray.push(segment.index);
				segment.drawRoad = true;
        if ((segment.p1.camera.z <= cameraDepth)         || // behind us
            (segment.p2.screen.y >= segment.p1.screen.y) || // back face cull
            (segment.p2.screen.y >= maxy)) {                 // clip by (already rendered) hill
					segment.drawRoad = false;
				} else {
					maxy = segment.p1.screen.y;
				}
      }

			//efh horizon test - now that we know maxy draw one large polygon for grass
			ctx.fillStyle = COLORS.DARK.grass;
      ctx.fillRect(0, maxy, width, height);
      //ctx.fillStyle = '#333333';
   //ctx.fillRect(0, 0, width, height);
			//efh offscreen render
			//ctx2.fillStyle = COLORS.DARK.grass;
      //ctx2.fillRect(0, maxy, width, height);


			// then draw segments (see modified render method to omit grass)
			//for(i = 0 ; i < segarray.length ; i++) {
			//for(i = (segarray.length-1) ; i >= 0 ; i--) {
			for(n = (drawDistance-1) ; n > 0 ; n--) {
				//segment = segments[segarray[i]];
				segment = segments[(baseSegment.index + n) % segments.length];
				//efh offscreen render
				//Render.segment(ctx2, width, lanes,
				
				// draw road segments
				if (segment.drawRoad) {
					Render.segment(ctx, width, lanes,
                      segment.p1.screen.x,
                      segment.p1.screen.y,
                      segment.p1.screen.w,
                      segment.p2.screen.x,
                      segment.p2.screen.y,
                      segment.p2.screen.w,
                      segment.fog,
                      segment.color);
//                      segment.color,
//											segment.p1.screen.scale, 
//											segment.timeMarker);
				}
				
				// draw stationary sprites
        for(i = 0 ; i < segment.sprites.length ; i++) {
          sprite      = segment.sprites[i];
          spriteScale = segment.p1.screen.scale;
					spriteX     = segment.p1.screen.x + (spriteScale * sprite.offset * roadWidth * width/2);
					spriteY     = segment.p1.screen.y;
					Render.sprite(ctx, width, height, resolution, roadWidth, sprites, sprite.source, spriteScale, spriteX, spriteY, sprite.offset , sprite.offsety, segment.clip);          
        }
				

				// draw time markers
				if (segment.timeMarker) {
					Render.timeMarker(ctx, width, lanes,
										 segment.p1.screen.x,
										 segment.p1.screen.y,
										 segment.p1.screen.w,
										 segment.clip,
										 segment.p1.screen.scale, 
										 segment.timeMarker);
				}

        // draw moving sprites
				for(i = 0; i < segment.cars.length ; i++) {
          car         = segment.cars[i];
          sprite      = car.sprite;
          spriteScale = Util.interpolate(segment.p1.screen.scale, segment.p2.screen.scale, car.percent);
          spriteX     = Util.interpolate(segment.p1.screen.x,     segment.p2.screen.x,     car.percent) + (spriteScale * car.offset * roadWidth * width/2);
          spriteY     = Util.interpolate(segment.p1.screen.y,     segment.p2.screen.y,     car.percent);
          Render.sprite(ctx, width, height, resolution, roadWidth, sprites, car.sprite, spriteScale, spriteX, spriteY, -0.5, -1, segment.clip);
        }

				// draw player sprite
        if (segment == playerSegment) {
				  //efh offscreen render
					//Render.player(ctx2, width, height, resolution, roadWidth, sprites, speed/maxSpeed,
          Render.player(ctx, width, height, resolution, roadWidth, sprites, speed/maxSpeed,
                        cameraDepth/playerZ,
                        width/2,
                        (height/2) - (cameraDepth/playerZ * Util.interpolate(playerSegment.p1.camera.y, playerSegment.p2.camera.y, playerPercent) * height/2),
                        speed * (keyLeft ? -1 : keyRight ? 1 : 0),
                        playerSegment.p2.world.y - playerSegment.p1.world.y);
        }
				
			}

			/*
			// pass thru segments again (this time all of them) from back to front
      for(n = (drawDistance-1) ; n > 0 ; n--) {
        segment = segments[(baseSegment.index + n) % segments.length];

        for(i = 0 ; i < segment.sprites.length ; i++) {
          sprite      = segment.sprites[i];
          spriteScale = segment.p1.screen.scale;
					spriteX     = segment.p1.screen.x + (spriteScale * sprite.offset * roadWidth * width/2);
					//try the following to create a sense of sprites coming at you from the right
          //spriteX     = (segment.p1.screen.x + (spriteScale * sprite.offset * roadWidth * width/2))*2;
					spriteY     = segment.p1.screen.y;
					//spriteY     = segment.p1.screen.y + (spriteScale * sprite.height);

					//Render.sprite(ctx, width, height, resolution, roadWidth, sprites, sprite.source, spriteScale, spriteX, spriteY, (sprite.offset < 0 ? -1 : 0), (sprite.offsety), segment.clip);          
					// change (sprite.offset < 0 ? -1 : 0) to just sprite.offset to allow sprites to be spread out further left and right
					Render.sprite(ctx, width, height, resolution, roadWidth, sprites, sprite.source, spriteScale, spriteX, spriteY, sprite.offset , sprite.offsety, segment.clip);          
					
					//efh offscreen render
          //Render.sprite(ctx, width, height, resolution, roadWidth, sprites, sprite.source, spriteScale, spriteX, spriteY, (sprite.offset < 0 ? -1 : 0), -1, segment.clip);
					//Render.sprite(ctx2, width, height, resolution, roadWidth, sprites, sprite.source, spriteScale, spriteX, spriteY, (sprite.offset < 0 ? -1 : 0), -1, segment.clip);
        }
				
//				if (segment.timeMarker) {
//					Render.timeMarker(ctx, width, lanes,
//										 segment.p1.screen.x,
//										 segment.p1.screen.y,
//										 segment.p1.screen.w,
//										 segment.clip,
//										 segment.p1.screen.scale, 
//										 segment.timeMarker);
//				}

        for(i = 0 ; i < segment.cars.length ; i++) {
          car         = segment.cars[i];
          sprite      = car.sprite;
          spriteScale = Util.interpolate(segment.p1.screen.scale, segment.p2.screen.scale, car.percent);
          spriteX     = Util.interpolate(segment.p1.screen.x,     segment.p2.screen.x,     car.percent) + (spriteScale * car.offset * roadWidth * width/2);
          spriteY     = Util.interpolate(segment.p1.screen.y,     segment.p2.screen.y,     car.percent);
					//efh offscreen render
          Render.sprite(ctx, width, height, resolution, roadWidth, sprites, car.sprite, spriteScale, spriteX, spriteY, -0.5, -1, segment.clip);
					//Render.sprite(ctx2, width, height, resolution, roadWidth, sprites, car.sprite, spriteScale, spriteX, spriteY, -0.5, -1, segment.clip);
        }


        if (segment == playerSegment) {
				  //efh offscreen render
					//Render.player(ctx2, width, height, resolution, roadWidth, sprites, speed/maxSpeed,
          Render.player(ctx, width, height, resolution, roadWidth, sprites, speed/maxSpeed,
                        cameraDepth/playerZ,
                        width/2,
                        (height/2) - (cameraDepth/playerZ * Util.interpolate(playerSegment.p1.camera.y, playerSegment.p2.camera.y, playerPercent) * height/2),
                        speed * (keyLeft ? -1 : keyRight ? 1 : 0),
                        playerSegment.p2.world.y - playerSegment.p1.world.y);
        }
      }

			// finally add timeMarkers (in reverse from horizon forward)
//			for(i = (segarray.length-1) ; i >= 0 ; i--) {
//				segment = segments[segarray[i]];
//				if (segment.timeMarker) {
//					Render.timeMarker(ctx, width, lanes,
//										 segment.p1.screen.x,
//										 segment.p1.screen.y,
//										 segment.p1.screen.w,
//										 segment.p1.screen.scale, 
//										 segment.timeMarker);
//				}
//			}				

			
		//efh moire test - restore canvas
	//ctx.restore();	
			
			//efh offscreen render
			// now copy offscreen canvas to onscreen one
			//ctx.clearRect(0, 0, width, height); //unnecessary?
			//ctx.drawImage(canvas2, 0, 0, width, height);
			//ctx.drawImage(canvas2, 0, 0);
			*/
			
			// if any explosion remaining display it
			
						//Fill the canvas with circles
						ctx.save();
						ctx.globalCompositeOperation = "lighter";
						for(var j = 0; j < circles.length; j++){
								var c = circles[j];
								
								//Create the circles
								ctx.beginPath();
								ctx.arc(c.x, c.y, c.radius, 0, Math.PI*2, false);
								ctx.fillStyle = "rgba("+c.r+", "+c.g+", "+c.b+", "+c.a+")";
								ctx.fill();
								
								c.x += c.vx;
								c.y += c.vy;
								//c.radius -= .05;
								c.radius += c.vr;
								c.a -= c.va;
								//if(c.radius < 0)
								if(c.radius > c.rmax || c.a < 0)
									circles.splice(j,1);
								//		circles[j] = new create();
						}
						ctx.restore();

			
			
			
    }

    function findSegment(z) {
      return segments[Math.floor(z/segmentLength) % segments.length]; 
    }

    //=========================================================================
    // BUILD ROAD GEOMETRY
    //=========================================================================

    function lastY() { return (segments.length == 0) ? 0 : segments[segments.length-1].p2.world.y; }

    function addSegment(curve, y) {
      var n = segments.length;
      segments.push({
          index: n,
             p1: { world: { y: lastY(), z:  n   *segmentLength }, camera: {}, screen: {} },
             p2: { world: { y: y,       z: (n+1)*segmentLength }, camera: {}, screen: {} },
          curve: curve,
        sprites: [],
           cars: [],
          color: Math.floor(n/rumbleLength)%2 ? COLORS.DARK : COLORS.LIGHT
      });
    }

    function addSprite(n, sprite, offset, offsety) {
			// increase negative offsety parm to allow sprites to be positioned above the ground
			// ground level is effectively -1 but needs to be slightly less to prevent illusion of sprites floating so try -.97
			offsety = offsety || -.97;
      segments[n].sprites.push({ source: sprite, offset: offset, offsety: offsety });
    }

    function addRoad(enter, hold, leave, curve, y) {
      var startY   = lastY();
      var endY     = startY + (Util.toInt(y, 0) * segmentLength);
      var n, total = enter + hold + leave;
      for(n = 0 ; n < enter ; n++)
        addSegment(Util.easeIn(0, curve, n/enter), Util.easeInOut(startY, endY, n/total));
      for(n = 0 ; n < hold  ; n++)
        addSegment(curve, Util.easeInOut(startY, endY, (enter+n)/total));
      for(n = 0 ; n < leave ; n++)
        addSegment(Util.easeInOut(curve, 0, n/leave), Util.easeInOut(startY, endY, (enter+hold+n)/total));
    }

    var ROAD = {
      LENGTH: { NONE: 0, SHORT:  25, MEDIUM:   50, LONG:  100 },
      HILL:   { NONE: 0, LOW:    20, MEDIUM:   40, HIGH:   60 },
      CURVE:  { NONE: 0, EASY:    2, MEDIUM:    4, HARD:    6 }
    };

    function addStraight(num) {
      num = num || ROAD.LENGTH.MEDIUM;
      addRoad(num, num, num, 0, 0);
    }

    function addHill(num, height) {
      num    = num    || ROAD.LENGTH.MEDIUM;
      height = height || ROAD.HILL.MEDIUM;
      addRoad(num, num, num, 0, height);
    }

    function addCurve(num, curve, height) {
      num    = num    || ROAD.LENGTH.MEDIUM;
      curve  = curve  || ROAD.CURVE.MEDIUM;
      height = height || ROAD.HILL.NONE;
      addRoad(num, num, num, curve, height);
    }
        
    function addLowRollingHills(num, height) {
      num    = num    || ROAD.LENGTH.SHORT;
      height = height || ROAD.HILL.LOW;
      addRoad(num, num, num,  0,                height/2);
      addRoad(num, num, num,  0,               -height);
      addRoad(num, num, num,  ROAD.CURVE.EASY,  height);
      addRoad(num, num, num,  0,                0);
      addRoad(num, num, num, -ROAD.CURVE.EASY,  height/2);
      addRoad(num, num, num,  0,                0);
    }

    function addSCurves() {
      addRoad(ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM,  -ROAD.CURVE.EASY,    ROAD.HILL.NONE);
      addRoad(ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM,   ROAD.CURVE.MEDIUM,  ROAD.HILL.MEDIUM);
      addRoad(ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM,   ROAD.CURVE.EASY,   -ROAD.HILL.LOW);
      addRoad(ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM,  -ROAD.CURVE.EASY,    ROAD.HILL.MEDIUM);
      addRoad(ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM,  -ROAD.CURVE.MEDIUM, -ROAD.HILL.MEDIUM);
    }

    function addBumps() {
      addRoad(10, 10, 10, 0,  5);
      addRoad(10, 10, 10, 0, -2);
      addRoad(10, 10, 10, 0, -5);
      addRoad(10, 10, 10, 0,  8);
      addRoad(10, 10, 10, 0,  5);
      addRoad(10, 10, 10, 0, -7);
      addRoad(10, 10, 10, 0,  5);
      addRoad(10, 10, 10, 0, -2);
    }

    function addDownhillToEnd(num) {
      num = num || 200;
      addRoad(num, num, num, -ROAD.CURVE.EASY, -lastY()/segmentLength);
    }

    function resetRoad() {
      segments = [];
			currentRotation =0;

      addStraight(ROAD.LENGTH.SHORT);
      for(n = 0 ; n < 2; n++) {
      addLowRollingHills();
			if (Util.randomInt(0,1)==0) {
				addCurve(ROAD.LENGTH.LONG*4, ROAD.CURVE.EASY, ROAD.HILL.LOW);
				addCurve(ROAD.LENGTH.LONG*4, ROAD.CURVE.HARD, ROAD.HILL.HIGH*3);
			} 
			if (Util.randomInt(0,1)==0) {
				addCurve(ROAD.LENGTH.LONG, ROAD.CURVE.HARD, ROAD.HILL.HIGH);
				addCurve(ROAD.LENGTH.LONG, -ROAD.CURVE.HARD, ROAD.HILL.HIGH);
			} else {
				addCurve(ROAD.LENGTH.MEDIUM, ROAD.CURVE.MEDIUM, ROAD.HILL.LOW);
				addCurve(ROAD.LENGTH.MEDIUM, -ROAD.CURVE.MEDIUM, ROAD.HILL.LOW);
			}
			if (Util.randomInt(0,1)==0) {
	      addSCurves();
			} else {
				addBumps();
			}
			
			if (Util.randomInt(0,1)==0) {
				addHill(ROAD.LENGTH.MEDIUM, ROAD.HILL.HIGH*2);
				addHill(ROAD.LENGTH.MEDIUM, -ROAD.HILL.HIGH*2);
			} else {
				addSCurves();
			}
			if (Util.randomInt(0,1)==0) {
				addCurve(ROAD.LENGTH.MEDIUM, ROAD.CURVE.MEDIUM, ROAD.HILL.LOW);
				addBumps();
			} else {
				addLowRollingHills();
			}
			if (Util.randomInt(0,1)==0) {
				addCurve(ROAD.LENGTH.LONG*2, ROAD.CURVE.MEDIUM, ROAD.HILL.MEDIUM);
				addStraight();
			} else {
				addCurve(ROAD.LENGTH.LONG*2, -ROAD.CURVE.MEDIUM, ROAD.HILL.MEDIUM);
				addHill(ROAD.LENGTH.LONG, ROAD.HILL.HIGH*1.5);
				addHill(ROAD.LENGTH.LONG, -ROAD.HILL.HIGH*1.5);
			}
			if (Util.randomInt(0,1)==0) {
				addHill(ROAD.LENGTH.MEDIUM, ROAD.HILL.HIGH);
				addSCurves();
				addSCurves();
			} else {
				addSCurves();
				addStraight(ROAD.LENGTH.LONG);
			}
			if (Util.randomInt(0,1)==0) {
				addCurve(ROAD.LENGTH.LONG, -ROAD.CURVE.MEDIUM, ROAD.HILL.NONE);
				addHill(ROAD.LENGTH.MEDIUM, ROAD.HILL.HIGH);
				addCurve(ROAD.LENGTH.LONG, ROAD.CURVE.MEDIUM, -ROAD.HILL.LOW);
			} else {
				addBumps();
				addHill(ROAD.LENGTH.LONG, -ROAD.HILL.MEDIUM);
			}
			if (Util.randomInt(0,1)==0) {
				addStraight();
				addSCurves();
			} else {
				addBumps();
				addHill(ROAD.LENGTH.LONG, ROAD.HILL.MEDIUM);
			}
			}
			
			
			
      addDownhillToEnd();

      resetSprites();
      resetCars();
			resetBikeCheckbox(document.getElementById('bike'));

      segments[findSegment(playerZ).index + 2].color = COLORS.START;
      segments[findSegment(playerZ).index + 3].color = COLORS.START;

			// test add some timeMarkers
			//segments[160].timeMarker = "1960";
			//segments[300].timeMarker = "1900";
			//segments[500].timeMarker = "1800";
			//segments[1000].timeMarker = "2000 BCE";
			//segments[2000].timeMarker = "96 mya";

			timeScale = Util.randomInt(0,8); 
			var timeSpacing = 500;
			var timeStart = 35;
			var timeToday = 2013;
			function timeMarkerVal(timeScale, n) { 
				if (n==timeStart) {
					return "Today";
				} else if (timeScale==0){ // every .5 billion years
					return Math.round(((n-timeStart)/(timeSpacing*2))*10)/10 + " b.y.a.";
					//return "-"+Math.round(((n-timeStart)/(timeSpacing*2))*10)/10 + "b"; 
				} else if (timeScale==1)	{ // every 50 million years
					var ya = ((n-timeStart)/(timeSpacing/50)) ;
					return (ya>=1000) ? (Math.round(ya/1000*100)/100)+" b.y.a." : ya + " m.y.a.";
					//return "-"+((n-timeStart)/(timeSpacing/50)) + "m"; 
				} else if (timeScale==2)	{ // every 5 million years
					var ya = ((n-timeStart)/(timeSpacing/5)) ;
					return (ya>=1000) ? (Math.round(ya/1000*1000)/1000)+" b.y.a." : ya + " m.y.a.";
					//return ((n-timeStart)/(timeSpacing/5)) + " m.y.a.";
					//return "-"+((n-timeStart)/(timeSpacing/5)) + "m";
				} else if (timeScale==3)	{ // every 1 million years
					return ((n-timeStart)/timeSpacing) + " m.y.a.";
					//return "-"+((n-timeStart)/timeSpacing) + "m";
				} else if (timeScale==4)	{ // every 50k years
					var ya = ((n-timeStart)/(timeSpacing/50)) ;
					return (ya>=1000) ? (Math.round(ya/1000*100)/100)+" m.y.a." : ya + " t.y.a.";
					//return ((n-timeStart)/(timeSpacing/50)) + " t.y.a.";
					//return "-"+((n-timeStart)/(timeSpacing/50)) + "k";
				} else if (timeScale==5)	{ // every 5k years
					return ((n-timeStart)/(timeSpacing/5)) + " t.y.a.";
					//return "-"+((n-timeStart)/(timeSpacing/5)) + "k";
				} else if (timeScale==6)	{ // every 500 years
					if (n-timeStart>2000) 
						return n-timeStart-2000 + " BCE" ;
					else 
						return 2000+timeStart-n + " CE";
				} else if (timeScale==7)	{  // every 5 years
					return timeToday-((n-timeStart)/100);
				} else if (timeScale==8)	{  // every year
					return timeToday-((n-timeStart)/500); 
				}
			}
			for(n = timeStart; n < segments.length ; n += timeSpacing) {
				segments[n].timeMarker = timeMarkerVal(timeScale, n);
			}
			
			// turn off end line
      //for(var n = 0 ; n < rumbleLength ; n++)
      //  segments[segments.length-1-n].color = COLORS.FINISH;

      trackLength = segments.length * segmentLength;
    }

    function resetSprites() {
      var n, i;

      //addSprite(20,  SPRITES.BILLBOARD07, -1);
      //addSprite(40,  SPRITES.BILLBOARD06, -1);
      //addSprite(60,  SPRITES.BILLBOARD08, -1);
      //addSprite(80,  SPRITES.BILLBOARD09, -1);
      //addSprite(100, SPRITES.BILLBOARD01, -.5,-1);
      //addSprite(120, SPRITES.BILLBOARD02, -.2,-2);
      //addSprite(140, SPRITES.BILLBOARD03, -.2,-2.8);
      //addSprite(160, SPRITES.BILLBOARD04, -.2,-4);
      //addSprite(180, SPRITES.BILLBOARD05, -.2,-6);

      addSprite(240,                  SPRITES.BILLBOARD07, -1.2);
      addSprite(240,                  SPRITES.BILLBOARD06,  2.2);
      addSprite(segments.length - 25, SPRITES.BILLBOARD07, -1.2);
      addSprite(segments.length - 25, SPRITES.BILLBOARD06,  2.2);

      for(n = 50 ; n < 200 ; n += 4 + Math.floor(n/100)) {
        addSprite(n, SPRITES.PALM_TREE, 1.5 + Math.random()*0.5);
        addSprite(n, SPRITES.PALM_TREE,   1 + Math.random()*2);
      }

      for(n = 250 ; n < 600 ; n += 5) {
        addSprite(n,     SPRITES.COLUMN, 1.8);
        addSprite(n + Util.randomInt(0,5), SPRITES.TREE1, -1 - (Math.random() * 2));
        addSprite(n + Util.randomInt(0,5), SPRITES.TREE2, -1 - (Math.random() * 2));
      }

      for(n = 200 ; n < segments.length ; n += 3) {
        addSprite(n, Util.randomChoice(SPRITES.PLANTS), Util.randomChoice([1,-1]) * (2 + Math.random() * 5));
      }

      var side, sprite, offset;
      for(n = 600 ; n < (segments.length-50) ; n += 100) {
        side      = Util.randomChoice([1, -1]);
        addSprite(n + Util.randomInt(0, 50), Util.randomChoice(SPRITES.BILLBOARDS), -side);
        for(i = 0 ; i < 20 ; i++) {
          sprite = Util.randomChoice(SPRITES.PLANTS);
					//increase second parm constant to spread sprites further out left and right
					offset = side * Util.randomInt(1, 10);
          //offset = side * (1.5 + Math.random());
          addSprite(n + Util.randomInt(0, 50), sprite, offset);
        }
          
      }

    }

    function resetCars() {
      cars = [];
      var n, car, segment, offset, z, sprite, speed;
      for (var n = 0 ; n < totalCars ; n++) {
        offset = Math.random() * Util.randomChoice([-0.8, 0.8]);
        z      = Math.floor(Math.random() * segments.length) * segmentLength;
        sprite = Util.randomChoice(SPRITES.CARS);
        speed  = maxSpeed/4 + Math.random() * maxSpeed/(sprite == SPRITES.SEMI ? 4 : 2);
        car = { offset: offset, z: z, sprite: sprite, speed: speed };
        segment = findSegment(car.z);
        segment.cars.push(car);
        cars.push(car);
      }
    }

    //=========================================================================
    // THE GAME LOOP
    //=========================================================================

    Game.run({
      canvas: canvas, render: render, update: update, stats: stats, step: step,
      images: ["background", "sprites"],
      keys: [
        { keys: [KEY.LEFT,  KEY.A], mode: 'down', action: function() { keyLeft   = true;  } },
        { keys: [KEY.RIGHT, KEY.D], mode: 'down', action: function() { keyRight  = true;  } },
        { keys: [KEY.UP,    KEY.W], mode: 'down', action: function() { keyFaster = true;  } },
        { keys: [KEY.DOWN,  KEY.S], mode: 'down', action: function() { keySlower = true;  } },
        { keys: [KEY.LEFT,  KEY.A], mode: 'up',   action: function() { keyLeft   = false; } },
        { keys: [KEY.RIGHT, KEY.D], mode: 'up',   action: function() { keyRight  = false; } },
        { keys: [KEY.UP,    KEY.W], mode: 'up',   action: function() { keyFaster = false; } },
        { keys: [KEY.DOWN,  KEY.S], mode: 'up',   action: function() { keySlower = false; } }
      ],
      ready: function(images) {
        background = images[0];
        sprites    = images[1];
        reset();
        /*
				Dom.storage.fast_lap_time = Dom.storage.fast_lap_time || 180;
        updateHud('fast_lap_time', formatTime(Util.toFloat(Dom.storage.fast_lap_time)));
				*/
      }
    });

    function reset(options) {
      options       = options || {};
      canvas.width  = width  = Util.toInt(options.width,          width);
      canvas.height = height = Util.toInt(options.height,         height);
			
			
      lanes                  = Util.toInt(options.lanes,          lanes);
      totalCars              = Util.toInt(options.totalCars,      totalCars);
      roadWidth              = Util.toInt(options.roadWidth,      roadWidth);
      cameraHeight           = Util.toInt(options.cameraHeight,   cameraHeight);
      drawDistance           = Util.toInt(options.drawDistance,   drawDistance);
      fogDensity             = Util.toInt(options.fogDensity,     fogDensity);
      fieldOfView            = Util.toInt(options.fieldOfView,    fieldOfView);
      segmentLength          = Util.toInt(options.segmentLength,  segmentLength);
      rumbleLength           = Util.toInt(options.rumbleLength,   rumbleLength);
      cameraDepth            = 1 / Math.tan((fieldOfView/2) * Math.PI/180);
      playerZ                = (cameraHeight * cameraDepth);
      resolution             = height/480;
      refreshTweakUI();

      if ((segments.length==0) || (options.segmentLength) || (options.rumbleLength))
        resetRoad(); // only rebuild road when necessary
    }
		
		function resetAutoSteerCheckbox(chkBox) {
			autoSteer = chkBox.checked ;
		}
		function resetBikeCheckbox(chkBox) {
			bike = chkBox.checked ;	
			if (bike) {
				reset({ cameraHeight: 650, roadWidth: 3000 });
				//cameraHeight   = 650;
				//roadWidth = 3000;
			} else {
				reset({ cameraHeight: 1000, roadWidth: 2000 });
				//cameraHeight   = 1000;
				//roadWidth = 2000;
			}
			refreshTweakUI();
		}

    //=========================================================================
    // TWEAK UI HANDLERS
    //=========================================================================

    Dom.on('resolution', 'change', function(ev) {
      var w, h, ratio;
      switch(ev.target.options[ev.target.selectedIndex].value) {
        case 'fine':   w = 1280; h = 960;  ratio=w/width; break;
        case 'high':   w = 1024; h = 768;  ratio=w/width; break;
        case 'medium': w = 640;  h = 480;  ratio=w/width; break;
        case 'low':    w = 480;  h = 360;  ratio=w/width; break;
      }
      reset({ width: w, height: h })
      Dom.blur(ev);
    });

    Dom.on('lanes',          'change', function(ev) { Dom.blur(ev); reset({ lanes:         ev.target.options[ev.target.selectedIndex].value }); });
    Dom.on('autoSteer',      'change', function(ev) { Dom.blur(ev); resetAutoSteerCheckbox(document.getElementById('autoSteer')); });
    Dom.on('bike',      'change', function(ev) { Dom.blur(ev); resetBikeCheckbox(document.getElementById('bike')); });
    Dom.on('totalCars',      'change', function(ev) { Dom.blur(ev); reset({ totalCars:     Util.limit(Util.toInt(ev.target.value), Util.toInt(ev.target.getAttribute('min')), Util.toInt(ev.target.getAttribute('max'))) }); resetRoad(); });
    Dom.on('roadWidth',      'change', function(ev) { Dom.blur(ev); reset({ roadWidth:     Util.limit(Util.toInt(ev.target.value), Util.toInt(ev.target.getAttribute('min')), Util.toInt(ev.target.getAttribute('max'))) }); });
    Dom.on('cameraHeight',   'change', function(ev) { Dom.blur(ev); reset({ cameraHeight:  Util.limit(Util.toInt(ev.target.value), Util.toInt(ev.target.getAttribute('min')), Util.toInt(ev.target.getAttribute('max'))) }); });
    Dom.on('drawDistance',   'change', function(ev) { Dom.blur(ev); reset({ drawDistance:  Util.limit(Util.toInt(ev.target.value), Util.toInt(ev.target.getAttribute('min')), Util.toInt(ev.target.getAttribute('max'))) }); });
    Dom.on('fieldOfView',    'change', function(ev) { Dom.blur(ev); reset({ fieldOfView:   Util.limit(Util.toInt(ev.target.value), Util.toInt(ev.target.getAttribute('min')), Util.toInt(ev.target.getAttribute('max'))) }); });
    Dom.on('fogDensity',     'change', function(ev) { Dom.blur(ev); reset({ fogDensity:    Util.limit(Util.toInt(ev.target.value), Util.toInt(ev.target.getAttribute('min')), Util.toInt(ev.target.getAttribute('max'))) }); });

    function refreshTweakUI() {
      Dom.get('lanes').selectedIndex = lanes-1;
			if (autoSteer) 
				 document.getElementById('autoSteer').checked = true;
			else 
				 document.getElementById('autoSteer').checked = false;
			if (bike) 
				 document.getElementById('bike').checked = true;
			else 
				 document.getElementById('bike').checked = false;
      Dom.get('currentTotalCars').innerHTML      = Dom.get('totalCars').value      = totalCars;
      Dom.get('currentRoadWidth').innerHTML      = Dom.get('roadWidth').value      = roadWidth;
      Dom.get('currentCameraHeight').innerHTML   = Dom.get('cameraHeight').value   = cameraHeight;
      Dom.get('currentDrawDistance').innerHTML   = Dom.get('drawDistance').value   = drawDistance;
      Dom.get('currentFieldOfView').innerHTML    = Dom.get('fieldOfView').value    = fieldOfView;
      Dom.get('currentFogDensity').innerHTML     = Dom.get('fogDensity').value     = fogDensity;
    }

    //=========================================================================

  </script>

</body> 
</html>
